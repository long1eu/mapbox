// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: sources.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Tophap_MapboxGl_Source {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var type: OneOf_Type? {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var geoJson: Tophap_MapboxGl_Source.GeoJson {
    get {
      if case .geoJson(let v)? = _storage._type {return v}
      return Tophap_MapboxGl_Source.GeoJson()
    }
    set {_uniqueStorage()._type = .geoJson(newValue)}
  }

  var image: Tophap_MapboxGl_Source.Image {
    get {
      if case .image(let v)? = _storage._type {return v}
      return Tophap_MapboxGl_Source.Image()
    }
    set {_uniqueStorage()._type = .image(newValue)}
  }

  var rasterDem: Tophap_MapboxGl_Source.RasterDem {
    get {
      if case .rasterDem(let v)? = _storage._type {return v}
      return Tophap_MapboxGl_Source.RasterDem()
    }
    set {_uniqueStorage()._type = .rasterDem(newValue)}
  }

  var raster: Tophap_MapboxGl_Source.Raster {
    get {
      if case .raster(let v)? = _storage._type {return v}
      return Tophap_MapboxGl_Source.Raster()
    }
    set {_uniqueStorage()._type = .raster(newValue)}
  }

  var vector: Tophap_MapboxGl_Source.Vector {
    get {
      if case .vector(let v)? = _storage._type {return v}
      return Tophap_MapboxGl_Source.Vector()
    }
    set {_uniqueStorage()._type = .vector(newValue)}
  }

  var unknown: Tophap_MapboxGl_Source.Unknown {
    get {
      if case .unknown(let v)? = _storage._type {return v}
      return Tophap_MapboxGl_Source.Unknown()
    }
    set {_uniqueStorage()._type = .unknown(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable {
    case geoJson(Tophap_MapboxGl_Source.GeoJson)
    case image(Tophap_MapboxGl_Source.Image)
    case rasterDem(Tophap_MapboxGl_Source.RasterDem)
    case raster(Tophap_MapboxGl_Source.Raster)
    case vector(Tophap_MapboxGl_Source.Vector)
    case unknown(Tophap_MapboxGl_Source.Unknown)

  #if !swift(>=4.1)
    static func ==(lhs: Tophap_MapboxGl_Source.OneOf_Type, rhs: Tophap_MapboxGl_Source.OneOf_Type) -> Bool {
      switch (lhs, rhs) {
      case (.geoJson(let l), .geoJson(let r)): return l == r
      case (.image(let l), .image(let r)): return l == r
      case (.rasterDem(let l), .rasterDem(let r)): return l == r
      case (.raster(let l), .raster(let r)): return l == r
      case (.vector(let l), .vector(let r)): return l == r
      case (.unknown(let l), .unknown(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  struct GeoJson {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String {
      get {return _storage._id}
      set {_uniqueStorage()._id = newValue}
    }

    var attribution: String {
      get {return _storage._attribution}
      set {_uniqueStorage()._attribution = newValue}
    }

    var options: Tophap_MapboxGl_Source.GeoJson.Options {
      get {return _storage._options ?? Tophap_MapboxGl_Source.GeoJson.Options()}
      set {_uniqueStorage()._options = newValue}
    }
    /// Returns true if `options` has been explicitly set.
    var hasOptions: Bool {return _storage._options != nil}
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    mutating func clearOptions() {_uniqueStorage()._options = nil}

    var source: OneOf_Source? {
      get {return _storage._source}
      set {_uniqueStorage()._source = newValue}
    }

    var uri: String {
      get {
        if case .uri(let v)? = _storage._source {return v}
        return String()
      }
      set {_uniqueStorage()._source = .uri(newValue)}
    }

    var geoJson: String {
      get {
        if case .geoJson(let v)? = _storage._source {return v}
        return String()
      }
      set {_uniqueStorage()._source = .geoJson(newValue)}
    }

    var asset: String {
      get {
        if case .asset(let v)? = _storage._source {return v}
        return String()
      }
      set {_uniqueStorage()._source = .asset(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Source: Equatable {
      case uri(String)
      case geoJson(String)
      case asset(String)

    #if !swift(>=4.1)
      static func ==(lhs: Tophap_MapboxGl_Source.GeoJson.OneOf_Source, rhs: Tophap_MapboxGl_Source.GeoJson.OneOf_Source) -> Bool {
        switch (lhs, rhs) {
        case (.uri(let l), .uri(let r)): return l == r
        case (.geoJson(let l), .geoJson(let r)): return l == r
        case (.asset(let l), .asset(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    struct Options {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var minZoom: Int32 = 0

      var maxZoom: Int32 = 0

      var buffer: Int32 = 0

      var lineMetrics: Bool = false

      var tolerance: Float = 0

      var cluster: Bool = false

      var clusterMaxZoom: Int32 = 0

      var clusterRadius: Int32 = 0

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Image {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String {
      get {return _storage._id}
      set {_uniqueStorage()._id = newValue}
    }

    var attribution: String {
      get {return _storage._attribution}
      set {_uniqueStorage()._attribution = newValue}
    }

    var coordinates: Tophap_MapboxGl_LatLngQuad {
      get {return _storage._coordinates ?? Tophap_MapboxGl_LatLngQuad()}
      set {_uniqueStorage()._coordinates = newValue}
    }
    /// Returns true if `coordinates` has been explicitly set.
    var hasCoordinates: Bool {return _storage._coordinates != nil}
    /// Clears the value of `coordinates`. Subsequent reads from it will return its default value.
    mutating func clearCoordinates() {_uniqueStorage()._coordinates = nil}

    var source: OneOf_Source? {
      get {return _storage._source}
      set {_uniqueStorage()._source = newValue}
    }

    var uri: String {
      get {
        if case .uri(let v)? = _storage._source {return v}
        return String()
      }
      set {_uniqueStorage()._source = .uri(newValue)}
    }

    var image: Data {
      get {
        if case .image(let v)? = _storage._source {return v}
        return SwiftProtobuf.Internal.emptyData
      }
      set {_uniqueStorage()._source = .image(newValue)}
    }

    var asset: String {
      get {
        if case .asset(let v)? = _storage._source {return v}
        return String()
      }
      set {_uniqueStorage()._source = .asset(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Source: Equatable {
      case uri(String)
      case image(Data)
      case asset(String)

    #if !swift(>=4.1)
      static func ==(lhs: Tophap_MapboxGl_Source.Image.OneOf_Source, rhs: Tophap_MapboxGl_Source.Image.OneOf_Source) -> Bool {
        switch (lhs, rhs) {
        case (.uri(let l), .uri(let r)): return l == r
        case (.image(let l), .image(let r)): return l == r
        case (.asset(let l), .asset(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct RasterDem {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String {
      get {return _storage._id}
      set {_uniqueStorage()._id = newValue}
    }

    var attribution: String {
      get {return _storage._attribution}
      set {_uniqueStorage()._attribution = newValue}
    }

    var tileSize: Int32 {
      get {return _storage._tileSize}
      set {_uniqueStorage()._tileSize = newValue}
    }

    var source: OneOf_Source? {
      get {return _storage._source}
      set {_uniqueStorage()._source = newValue}
    }

    var uri: String {
      get {
        if case .uri(let v)? = _storage._source {return v}
        return String()
      }
      set {_uniqueStorage()._source = .uri(newValue)}
    }

    var tileSet: Tophap_MapboxGl_Source.TileSet {
      get {
        if case .tileSet(let v)? = _storage._source {return v}
        return Tophap_MapboxGl_Source.TileSet()
      }
      set {_uniqueStorage()._source = .tileSet(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Source: Equatable {
      case uri(String)
      case tileSet(Tophap_MapboxGl_Source.TileSet)

    #if !swift(>=4.1)
      static func ==(lhs: Tophap_MapboxGl_Source.RasterDem.OneOf_Source, rhs: Tophap_MapboxGl_Source.RasterDem.OneOf_Source) -> Bool {
        switch (lhs, rhs) {
        case (.uri(let l), .uri(let r)): return l == r
        case (.tileSet(let l), .tileSet(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Raster {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String {
      get {return _storage._id}
      set {_uniqueStorage()._id = newValue}
    }

    var attribution: String {
      get {return _storage._attribution}
      set {_uniqueStorage()._attribution = newValue}
    }

    var tileSize: Int32 {
      get {return _storage._tileSize}
      set {_uniqueStorage()._tileSize = newValue}
    }

    var source: OneOf_Source? {
      get {return _storage._source}
      set {_uniqueStorage()._source = newValue}
    }

    var uri: String {
      get {
        if case .uri(let v)? = _storage._source {return v}
        return String()
      }
      set {_uniqueStorage()._source = .uri(newValue)}
    }

    var tileSet: Tophap_MapboxGl_Source.TileSet {
      get {
        if case .tileSet(let v)? = _storage._source {return v}
        return Tophap_MapboxGl_Source.TileSet()
      }
      set {_uniqueStorage()._source = .tileSet(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Source: Equatable {
      case uri(String)
      case tileSet(Tophap_MapboxGl_Source.TileSet)

    #if !swift(>=4.1)
      static func ==(lhs: Tophap_MapboxGl_Source.Raster.OneOf_Source, rhs: Tophap_MapboxGl_Source.Raster.OneOf_Source) -> Bool {
        switch (lhs, rhs) {
        case (.uri(let l), .uri(let r)): return l == r
        case (.tileSet(let l), .tileSet(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Vector {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String {
      get {return _storage._id}
      set {_uniqueStorage()._id = newValue}
    }

    var attribution: String {
      get {return _storage._attribution}
      set {_uniqueStorage()._attribution = newValue}
    }

    var source: OneOf_Source? {
      get {return _storage._source}
      set {_uniqueStorage()._source = newValue}
    }

    var uri: String {
      get {
        if case .uri(let v)? = _storage._source {return v}
        return String()
      }
      set {_uniqueStorage()._source = .uri(newValue)}
    }

    var tileSet: Tophap_MapboxGl_Source.TileSet {
      get {
        if case .tileSet(let v)? = _storage._source {return v}
        return Tophap_MapboxGl_Source.TileSet()
      }
      set {_uniqueStorage()._source = .tileSet(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Source: Equatable {
      case uri(String)
      case tileSet(Tophap_MapboxGl_Source.TileSet)

    #if !swift(>=4.1)
      static func ==(lhs: Tophap_MapboxGl_Source.Vector.OneOf_Source, rhs: Tophap_MapboxGl_Source.Vector.OneOf_Source) -> Bool {
        switch (lhs, rhs) {
        case (.uri(let l), .uri(let r)): return l == r
        case (.tileSet(let l), .tileSet(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Unknown {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String = String()

    var attribution: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct TileSet {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var tileJson: String = String()

    var name: String = String()

    var description_p: String = String()

    var version: String = String()

    var attribution: String = String()

    var template: String = String()

    var legend: String = String()

    var scheme: String = String()

    var tiles: [String] = []

    var grids: [String] = []

    var data: [String] = []

    var minZoom: Float = 0

    var maxZoom: Float = 0

    var bounds: [Float] = []

    var center: [Float] = []

    var encoding: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tophap.mapbox_gl"

extension Tophap_MapboxGl_Source: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Source"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "geoJson"),
    3: .same(proto: "image"),
    4: .standard(proto: "raster_dem"),
    5: .same(proto: "raster"),
    6: .same(proto: "vector"),
    7: .same(proto: "unknown"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _type: Tophap_MapboxGl_Source.OneOf_Type?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _type = source._type
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2:
          var v: Tophap_MapboxGl_Source.GeoJson?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .geoJson(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .geoJson(v)}
        case 3:
          var v: Tophap_MapboxGl_Source.Image?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .image(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .image(v)}
        case 4:
          var v: Tophap_MapboxGl_Source.RasterDem?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .rasterDem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .rasterDem(v)}
        case 5:
          var v: Tophap_MapboxGl_Source.Raster?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .raster(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .raster(v)}
        case 6:
          var v: Tophap_MapboxGl_Source.Vector?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .vector(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .vector(v)}
        case 7:
          var v: Tophap_MapboxGl_Source.Unknown?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .unknown(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .unknown(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      switch _storage._type {
      case .geoJson(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .image(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .rasterDem(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .raster(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .vector(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .unknown(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tophap_MapboxGl_Source, rhs: Tophap_MapboxGl_Source) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._type != rhs_storage._type {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tophap_MapboxGl_Source.GeoJson: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tophap_MapboxGl_Source.protoMessageName + ".GeoJson"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "attribution"),
    3: .same(proto: "options"),
    4: .same(proto: "uri"),
    5: .standard(proto: "geo_json"),
    6: .same(proto: "asset"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _attribution: String = String()
    var _options: Tophap_MapboxGl_Source.GeoJson.Options? = nil
    var _source: Tophap_MapboxGl_Source.GeoJson.OneOf_Source?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _attribution = source._attribution
      _options = source._options
      _source = source._source
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._attribution)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._options)
        case 4:
          if _storage._source != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._source = .uri(v)}
        case 5:
          if _storage._source != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._source = .geoJson(v)}
        case 6:
          if _storage._source != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._source = .asset(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._attribution.isEmpty {
        try visitor.visitSingularStringField(value: _storage._attribution, fieldNumber: 2)
      }
      if let v = _storage._options {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      switch _storage._source {
      case .uri(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      case .geoJson(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      case .asset(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tophap_MapboxGl_Source.GeoJson, rhs: Tophap_MapboxGl_Source.GeoJson) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._attribution != rhs_storage._attribution {return false}
        if _storage._options != rhs_storage._options {return false}
        if _storage._source != rhs_storage._source {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tophap_MapboxGl_Source.GeoJson.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tophap_MapboxGl_Source.GeoJson.protoMessageName + ".Options"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_zoom"),
    2: .standard(proto: "max_zoom"),
    3: .same(proto: "buffer"),
    4: .standard(proto: "line_metrics"),
    5: .same(proto: "tolerance"),
    6: .same(proto: "cluster"),
    7: .standard(proto: "cluster_max_zoom"),
    8: .standard(proto: "cluster_radius"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.minZoom)
      case 2: try decoder.decodeSingularInt32Field(value: &self.maxZoom)
      case 3: try decoder.decodeSingularInt32Field(value: &self.buffer)
      case 4: try decoder.decodeSingularBoolField(value: &self.lineMetrics)
      case 5: try decoder.decodeSingularFloatField(value: &self.tolerance)
      case 6: try decoder.decodeSingularBoolField(value: &self.cluster)
      case 7: try decoder.decodeSingularInt32Field(value: &self.clusterMaxZoom)
      case 8: try decoder.decodeSingularInt32Field(value: &self.clusterRadius)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minZoom != 0 {
      try visitor.visitSingularInt32Field(value: self.minZoom, fieldNumber: 1)
    }
    if self.maxZoom != 0 {
      try visitor.visitSingularInt32Field(value: self.maxZoom, fieldNumber: 2)
    }
    if self.buffer != 0 {
      try visitor.visitSingularInt32Field(value: self.buffer, fieldNumber: 3)
    }
    if self.lineMetrics != false {
      try visitor.visitSingularBoolField(value: self.lineMetrics, fieldNumber: 4)
    }
    if self.tolerance != 0 {
      try visitor.visitSingularFloatField(value: self.tolerance, fieldNumber: 5)
    }
    if self.cluster != false {
      try visitor.visitSingularBoolField(value: self.cluster, fieldNumber: 6)
    }
    if self.clusterMaxZoom != 0 {
      try visitor.visitSingularInt32Field(value: self.clusterMaxZoom, fieldNumber: 7)
    }
    if self.clusterRadius != 0 {
      try visitor.visitSingularInt32Field(value: self.clusterRadius, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tophap_MapboxGl_Source.GeoJson.Options, rhs: Tophap_MapboxGl_Source.GeoJson.Options) -> Bool {
    if lhs.minZoom != rhs.minZoom {return false}
    if lhs.maxZoom != rhs.maxZoom {return false}
    if lhs.buffer != rhs.buffer {return false}
    if lhs.lineMetrics != rhs.lineMetrics {return false}
    if lhs.tolerance != rhs.tolerance {return false}
    if lhs.cluster != rhs.cluster {return false}
    if lhs.clusterMaxZoom != rhs.clusterMaxZoom {return false}
    if lhs.clusterRadius != rhs.clusterRadius {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tophap_MapboxGl_Source.Image: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tophap_MapboxGl_Source.protoMessageName + ".Image"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "attribution"),
    3: .same(proto: "coordinates"),
    4: .same(proto: "uri"),
    5: .same(proto: "image"),
    6: .same(proto: "asset"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _attribution: String = String()
    var _coordinates: Tophap_MapboxGl_LatLngQuad? = nil
    var _source: Tophap_MapboxGl_Source.Image.OneOf_Source?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _attribution = source._attribution
      _coordinates = source._coordinates
      _source = source._source
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._attribution)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._coordinates)
        case 4:
          if _storage._source != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._source = .uri(v)}
        case 5:
          if _storage._source != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._source = .image(v)}
        case 6:
          if _storage._source != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._source = .asset(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._attribution.isEmpty {
        try visitor.visitSingularStringField(value: _storage._attribution, fieldNumber: 2)
      }
      if let v = _storage._coordinates {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      switch _storage._source {
      case .uri(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      case .image(let v)?:
        try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
      case .asset(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tophap_MapboxGl_Source.Image, rhs: Tophap_MapboxGl_Source.Image) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._attribution != rhs_storage._attribution {return false}
        if _storage._coordinates != rhs_storage._coordinates {return false}
        if _storage._source != rhs_storage._source {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tophap_MapboxGl_Source.RasterDem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tophap_MapboxGl_Source.protoMessageName + ".RasterDem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "attribution"),
    3: .standard(proto: "tile_size"),
    4: .same(proto: "uri"),
    5: .standard(proto: "tile_set"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _attribution: String = String()
    var _tileSize: Int32 = 0
    var _source: Tophap_MapboxGl_Source.RasterDem.OneOf_Source?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _attribution = source._attribution
      _tileSize = source._tileSize
      _source = source._source
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._attribution)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._tileSize)
        case 4:
          if _storage._source != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._source = .uri(v)}
        case 5:
          var v: Tophap_MapboxGl_Source.TileSet?
          if let current = _storage._source {
            try decoder.handleConflictingOneOf()
            if case .tileSet(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._source = .tileSet(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._attribution.isEmpty {
        try visitor.visitSingularStringField(value: _storage._attribution, fieldNumber: 2)
      }
      if _storage._tileSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._tileSize, fieldNumber: 3)
      }
      switch _storage._source {
      case .uri(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      case .tileSet(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tophap_MapboxGl_Source.RasterDem, rhs: Tophap_MapboxGl_Source.RasterDem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._attribution != rhs_storage._attribution {return false}
        if _storage._tileSize != rhs_storage._tileSize {return false}
        if _storage._source != rhs_storage._source {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tophap_MapboxGl_Source.Raster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tophap_MapboxGl_Source.protoMessageName + ".Raster"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "attribution"),
    3: .standard(proto: "tile_size"),
    4: .same(proto: "uri"),
    5: .standard(proto: "tile_set"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _attribution: String = String()
    var _tileSize: Int32 = 0
    var _source: Tophap_MapboxGl_Source.Raster.OneOf_Source?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _attribution = source._attribution
      _tileSize = source._tileSize
      _source = source._source
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._attribution)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._tileSize)
        case 4:
          if _storage._source != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._source = .uri(v)}
        case 5:
          var v: Tophap_MapboxGl_Source.TileSet?
          if let current = _storage._source {
            try decoder.handleConflictingOneOf()
            if case .tileSet(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._source = .tileSet(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._attribution.isEmpty {
        try visitor.visitSingularStringField(value: _storage._attribution, fieldNumber: 2)
      }
      if _storage._tileSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._tileSize, fieldNumber: 3)
      }
      switch _storage._source {
      case .uri(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      case .tileSet(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tophap_MapboxGl_Source.Raster, rhs: Tophap_MapboxGl_Source.Raster) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._attribution != rhs_storage._attribution {return false}
        if _storage._tileSize != rhs_storage._tileSize {return false}
        if _storage._source != rhs_storage._source {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tophap_MapboxGl_Source.Vector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tophap_MapboxGl_Source.protoMessageName + ".Vector"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "attribution"),
    3: .same(proto: "uri"),
    4: .standard(proto: "tile_set"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _attribution: String = String()
    var _source: Tophap_MapboxGl_Source.Vector.OneOf_Source?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _attribution = source._attribution
      _source = source._source
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._attribution)
        case 3:
          if _storage._source != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._source = .uri(v)}
        case 4:
          var v: Tophap_MapboxGl_Source.TileSet?
          if let current = _storage._source {
            try decoder.handleConflictingOneOf()
            if case .tileSet(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._source = .tileSet(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._attribution.isEmpty {
        try visitor.visitSingularStringField(value: _storage._attribution, fieldNumber: 2)
      }
      switch _storage._source {
      case .uri(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      case .tileSet(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tophap_MapboxGl_Source.Vector, rhs: Tophap_MapboxGl_Source.Vector) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._attribution != rhs_storage._attribution {return false}
        if _storage._source != rhs_storage._source {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tophap_MapboxGl_Source.Unknown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tophap_MapboxGl_Source.protoMessageName + ".Unknown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "attribution"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.attribution)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.attribution.isEmpty {
      try visitor.visitSingularStringField(value: self.attribution, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tophap_MapboxGl_Source.Unknown, rhs: Tophap_MapboxGl_Source.Unknown) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.attribution != rhs.attribution {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tophap_MapboxGl_Source.TileSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Tophap_MapboxGl_Source.protoMessageName + ".TileSet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tile_json"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .same(proto: "version"),
    5: .same(proto: "attribution"),
    6: .same(proto: "template"),
    7: .same(proto: "legend"),
    8: .same(proto: "scheme"),
    9: .same(proto: "tiles"),
    10: .same(proto: "grids"),
    11: .same(proto: "data"),
    12: .standard(proto: "min_zoom"),
    13: .standard(proto: "max_zoom"),
    14: .same(proto: "bounds"),
    15: .same(proto: "center"),
    16: .same(proto: "encoding"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.tileJson)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularStringField(value: &self.description_p)
      case 4: try decoder.decodeSingularStringField(value: &self.version)
      case 5: try decoder.decodeSingularStringField(value: &self.attribution)
      case 6: try decoder.decodeSingularStringField(value: &self.template)
      case 7: try decoder.decodeSingularStringField(value: &self.legend)
      case 8: try decoder.decodeSingularStringField(value: &self.scheme)
      case 9: try decoder.decodeRepeatedStringField(value: &self.tiles)
      case 10: try decoder.decodeRepeatedStringField(value: &self.grids)
      case 11: try decoder.decodeRepeatedStringField(value: &self.data)
      case 12: try decoder.decodeSingularFloatField(value: &self.minZoom)
      case 13: try decoder.decodeSingularFloatField(value: &self.maxZoom)
      case 14: try decoder.decodeRepeatedFloatField(value: &self.bounds)
      case 15: try decoder.decodeRepeatedFloatField(value: &self.center)
      case 16: try decoder.decodeSingularStringField(value: &self.encoding)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tileJson.isEmpty {
      try visitor.visitSingularStringField(value: self.tileJson, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 4)
    }
    if !self.attribution.isEmpty {
      try visitor.visitSingularStringField(value: self.attribution, fieldNumber: 5)
    }
    if !self.template.isEmpty {
      try visitor.visitSingularStringField(value: self.template, fieldNumber: 6)
    }
    if !self.legend.isEmpty {
      try visitor.visitSingularStringField(value: self.legend, fieldNumber: 7)
    }
    if !self.scheme.isEmpty {
      try visitor.visitSingularStringField(value: self.scheme, fieldNumber: 8)
    }
    if !self.tiles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tiles, fieldNumber: 9)
    }
    if !self.grids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.grids, fieldNumber: 10)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedStringField(value: self.data, fieldNumber: 11)
    }
    if self.minZoom != 0 {
      try visitor.visitSingularFloatField(value: self.minZoom, fieldNumber: 12)
    }
    if self.maxZoom != 0 {
      try visitor.visitSingularFloatField(value: self.maxZoom, fieldNumber: 13)
    }
    if !self.bounds.isEmpty {
      try visitor.visitPackedFloatField(value: self.bounds, fieldNumber: 14)
    }
    if !self.center.isEmpty {
      try visitor.visitPackedFloatField(value: self.center, fieldNumber: 15)
    }
    if !self.encoding.isEmpty {
      try visitor.visitSingularStringField(value: self.encoding, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tophap_MapboxGl_Source.TileSet, rhs: Tophap_MapboxGl_Source.TileSet) -> Bool {
    if lhs.tileJson != rhs.tileJson {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.version != rhs.version {return false}
    if lhs.attribution != rhs.attribution {return false}
    if lhs.template != rhs.template {return false}
    if lhs.legend != rhs.legend {return false}
    if lhs.scheme != rhs.scheme {return false}
    if lhs.tiles != rhs.tiles {return false}
    if lhs.grids != rhs.grids {return false}
    if lhs.data != rhs.data {return false}
    if lhs.minZoom != rhs.minZoom {return false}
    if lhs.maxZoom != rhs.maxZoom {return false}
    if lhs.bounds != rhs.bounds {return false}
    if lhs.center != rhs.center {return false}
    if lhs.encoding != rhs.encoding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
